<!DOCTYPE html>
<meta charset="utf-8">
<style>

.node {
  stroke: #fff;
  stroke-width: 1.5px;
}

.link {
  stroke: #999;
  stroke-opacity: .6;
  fill: none;
  /*stroke: #666;*/
  stroke-width: 1.5px;
}

text {
  stroke: #000;
  font: 10px sans-serif;
  font-weight: normal;
  font-style: normal;
  pointer-events: none;
}


</style>
<body>
<script src="Scripts/d3.v3.js"></script>
<script src="origin.js"></script>
<script>

//  ===================================================
//  =============== CONFIGURABLE PARAMS  ==============
//  ===================================================

var width = 1900,
    height = 800;

// Think about it like it's neytrons - more charge, more dinstance
var default_charge_value = -600; 

var default_link_distance = 20;   

// How far can we change default_link_distance?
// 0   - I don't care
// 0.5 - Change it as you want, but it's preferrable to have default_link_distance 
// 1   - One does not change default_link_distance
var default_link_strength = 0.4;

// Should I comment this?
var deafult_circle_radius = 20;

// you can set it to true, but this will not help to understanf what's going on
var show_texts_near_circles = false;
var default_max_texts_length = 100;

// Should we use regexp-based  grouping or not
var use_regexp_color_grouping_matchers = false;

// Each item thet matches specified regexps will be placed to correspondent group with unique color
var regexp_color_matchers = [
  "^NI",  // Nimbus
  "^UI",  // UIKit
  "^NS",  // Foundation
  "^CA",  // Core animations
];


//  ===================================================
//  =============== CONFIGURABLE PARAMS ENDS ==========
//  ===================================================



//  ===================================================
//  =============== PARSING ===========================
//  ===================================================
var correctGraph = {};
var correctNodes = [];
var correctLinks = [];
var nodesSet = {};
var prefixes = {};

for (var i = 0; i < dependencies.links.length; i++) {
  var object = dependencies.links[i];

  var source = nodesSet[object.source];
  if (source == null) {
     source = {
        name : object.source, 
        source : 1,
        dest   : 0
     }
     nodesSet[object.source] = source;
  }
  source.source++;

  var dest = nodesSet[object.dest];
  if (dest == null) {
     dest = {
        name : object.dest, 
        source : 0,
        dest   : 1
     }
     nodesSet[object.dest] = dest;
  }
  dest.dest++;

  // Grouping by prefixes
  var sourcePrefix = object.source.substring(0,2);
  var destPrefix = object.dest.substring(0,2);


  if (!(sourcePrefix in prefixes)) {
    prefixes[sourcePrefix] = 1
  } else {
    prefixes[sourcePrefix]++;
  }

  if (!(destPrefix in prefixes)) {
    prefixes[destPrefix] = 1
  } else {
    prefixes[destPrefix]++;
  }

};

// Sort prefixes
var prefixes_groups = {};
var prefixes_arr = [];
for (var key in prefixes) {
    prefixes_arr.push( {key : key, value:prefixes[key] });
}

var sorted_prefixes = prefixes_arr.slice(0).sort(function(a, b) {
   return b.value - a.value;
});


var idx = 0;
for (var p in nodesSet) {
  var groupId = 0;


  if (use_regexp_color_grouping_matchers)  {
    for (var i = 0; i < regexp_color_matchers.length; i++) {
      var re = new RegExp(regexp_color_matchers[i],"");
      if (p.match(re)) {
        groupId = i + 1;
      }
    };
  } else {
     for (var i in sorted_prefixes) {
     var str = sorted_prefixes[i].key;
     // console.log("Checking " + p + " for " + str)
       if (p.slice(0, str.length) == str) {
         groupId = i;
         break;
       }
     }
  }


  // It's time to create node :)
  correctNodes.push({
    idx : idx,
    name : p,
    group : groupId,
    source : nodesSet[p].source,
    dest : nodesSet[p].dest,
    weight : nodesSet[p].source
  });
  console.log( " Pushing node : IDX="+idx+", name="+p+", groupId="+groupId+", source="+nodesSet[p].source+", dest="+nodesSet[p].dest+", weight="+nodesSet[p].source );
  nodesSet[p].idx = idx;
  idx++;
}

for (var i = 0; i < dependencies.links.length; i++) {
  var link = dependencies.links[i];
  var sourceIdx = nodesSet[link.source].idx;
  var destIdx = nodesSet[link.dest].idx;
  correctLinks.push({
    source : sourceIdx,
    target : destIdx,
    value : nodesSet[link.source].source,
    sourceNode : nodesSet[link.source],
    targetNode : nodesSet[link.dest]
  });
    console.log( "Pushing link : source="+sourceIdx+", target="+destIdx);

}


correctGraph["nodes"] = correctNodes;
correctGraph["links"] = correctLinks;


//  ===================================================
//  =============== PARSING ENDS  =====================
//  ===================================================



//  ===================================================
//  =============== http://d3js.org/ Magic ===========
//  ===================================================


var graph = correctGraph;

// https://github.com/mbostock/d3/wiki/Ordinal-Scales#categorical-colors
var color = d3.scale.category10();

var force = d3.layout.force()
    .charge(function(d) { return -d.weight * 200;})
    .linkDistance(default_link_distance)
    .size([width, height]);

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

  force
      .nodes(d3.values(graph.nodes))
      .links(graph.links)
      .linkStrength(default_link_strength)
      .start();

svg.append("defs").selectAll("marker")
    .data(["suit"])
  .enter().append("marker")
    .attr("id", function(d) { return d; })
    .attr("viewBox", "0 -5 10 10")
    .attr("refX", 10)
    .attr("refY", 0)
    .attr("markerWidth", 10)
    .attr("markerHeight", 10)
    .attr("orient", "auto")
  .append("path")
    .attr("d", "M0,-5L10,0L0,5");

var link = svg.append("g").selectAll("path")
    .data(graph.links).
    enter().append("path")
    .attr("class", "link")
    .attr("marker-end", "url(#suit)")
    .style("stroke-width", function(d) { return Math.sqrt(1); })


var node = svg.append("g").selectAll(".node")
    .data(graph.nodes)
    .enter().append("circle")
    .attr("r", radius)
    .style("fill", function(d) { return color(d.group) })
    .call(force.drag);

 //  // Uncomment to have names near the classes

  var text = null;
  if (show_texts_near_circles) {
   text = svg.append("g").selectAll("text")
    .data(force.nodes())
     .enter().append("text")
    .style("text-anchor", "middle")
    .text(function(d) { return d.name.substring(0,default_max_texts_length) });
  }
 
  force.on("tick", function() {
    link.attr("d", linkArc);
    node.attr("transform", transform );
    if (text != null) {
     text.attr("transform", transform);
    }
  });

  function linkArc(d) {
  var dx = d.target.x - d.source.x,
      dy = d.target.y - d.source.y,
      dr = Math.sqrt(dx * dx + dy * dy);

  var rsource = radius(d.sourceNode)/dr;
  var rdest = radius(d.targetNode)/dr;
  var startX = d.source.x + dx * rsource;      
  var startY = d.source.y + dy * rsource;      

  var endX = d.target.x - dx * rdest;      
  var endY = d.target.y - dy * rdest;      

  return "M" + startX+ "," + startY + "L" + endX+ "," + endY;
}

function transform(d) {
  return "translate(" + d.x + "," + d.y + ")";
}

function radius(d) {
  return deafult_circle_radius + d.source * deafult_circle_radius / 5;
}

</script>